<snippet>
  <content><![CDATA[- name: ${1:Generate OpenSSL Certificate Signing Request (CSR)}
  community.crypto.openssl_csr:
    state: ${2:# Whether the certificate signing request should exist or not, taking action if the state is different from what is stated}
    force: ${3:# Should the certificate signing request be forced regenerated by this ansible module}
    path: ${4:# The name of the file into which the generated OpenSSL certificate signing request will be written}
    backup: ${5:# Create a backup file including a timestamp so you can get the original CSR back if you overwrote it with a new one by accident}
    return_content: ${6:# If set to C(true), will return the (current or generated) CSR's content as I(csr)}
    privatekey_content: ${7:# The content of the private key to use when signing the certificate signing request}
    name_constraints_permitted: ${8:# For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is allowed to issue certificates for}
    name_constraints_excluded: ${9:# For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is B(not) allowed to issue certificates for}
    name_constraints_critical: ${10:# Should the Name Constraints extension be considered as critical}
    mode: ${11:# The permissions the resulting filesystem object should have}
    owner: ${12:# Name of the user that should own the filesystem object, as would be fed to I(chown)}
    group: ${13:# Name of the group that should own the filesystem object, as would be fed to I(chown)}
    seuser: ${14:# The user part of the SELinux filesystem object context}
    serole: ${15:# The role part of the SELinux filesystem object context}
    setype: ${16:# The type part of the SELinux filesystem object context}
    selevel: ${17:# The level part of the SELinux filesystem object context}
    unsafe_writes: ${18:# Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object}
    attributes: ${19:# The attributes the resulting filesystem object should have}
    digest: ${20:# The digest used when signing the certificate signing request with the private key}
    privatekey_path: ${21:# The path to the private key to use when signing the certificate signing request}
    privatekey_passphrase: ${22:# The passphrase for the private key}
    version: ${23:# The version of the certificate signing request}
    subject: ${24:# Key/value pairs that will be present in the subject name field of the certificate signing request}
    subject_ordered: ${25:# A list of dictionaries, where every dictionary must contain one key/value pair}
    country_name: ${26:# The countryName field of the certificate signing request subject}
    state_or_province_name: ${27:# The stateOrProvinceName field of the certificate signing request subject}
    locality_name: ${28:# The localityName field of the certificate signing request subject}
    organization_name: ${29:# The organizationName field of the certificate signing request subject}
    organizational_unit_name: ${30:# The organizationalUnitName field of the certificate signing request subject}
    common_name: ${31:# The commonName field of the certificate signing request subject}
    email_address: ${32:# The emailAddress field of the certificate signing request subject}
    subject_alt_name: ${33:# Subject Alternative Name (SAN) extension to attach to the certificate signing request}
    subject_alt_name_critical: ${34:# Should the subjectAltName extension be considered as critical}
    use_common_name_for_san: ${35:# If set to C(true), the module will fill the common name in for C(subject_alt_name) with C(DNS:) prefix if no SAN is specified}
    key_usage: ${36:# This defines the purpose (for example encipherment, signature, certificate signing) of the key contained in the certificate}
    key_usage_critical: ${37:# Should the keyUsage extension be considered as critical}
    extended_key_usage: ${38:# Additional restrictions (for example client authentication, server authentication) on the allowed purposes for which the public key may be used}
    extended_key_usage_critical: ${39:# Should the extkeyUsage extension be considered as critical}
    basic_constraints: ${40:# Indicates basic constraints, such as if the certificate is a CA}
    basic_constraints_critical: ${41:# Should the basicConstraints extension be considered as critical}
    ocsp_must_staple: ${42:# Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools}
    ocsp_must_staple_critical: ${43:# Should the OCSP Must Staple extension be considered as critical}
    select_crypto_backend: ${44:# Determines which crypto backend to use}
    create_subject_key_identifier: ${45:# Create the Subject Key Identifier from the public key}
    subject_key_identifier: ${46:# The subject key identifier as a hex string, where two bytes are separated by colons}
    authority_key_identifier: ${47:# The authority key identifier as a hex string, where two bytes are separated by colons}
    authority_cert_issuer: ${48:# Names that will be present in the authority cert issuer field of the certificate signing request}
    authority_cert_serial_number: ${49:# The authority cert serial number}
    crl_distribution_points: ${50:# Allows to specify one or multiple CRL distribution points}
  tags:
    - community
    - crypto
    - openssl_csr]]></content>
  <tabTrigger>community.crypto.openssl_csr</tabTrigger>
  <scope>source.yaml,source.ansible</scope>
  <description>Generate OpenSSL Certificate Signing Request (CSR)</description>
</snippet>