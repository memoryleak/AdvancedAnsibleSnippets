<snippet>
  <content><![CDATA[- name: ${1:Generate OpenSSL Certificate Signing Request (CSR)}
  community.crypto.openssl_csr:
    attributes: ${2:# The attributes the resulting filesystem object should have}
    authority_cert_issuer: ${3:# Names that will be present in the authority cert issuer field of the certificate signing request}
    authority_cert_serial_number: ${4:# The authority cert serial number}
    authority_key_identifier: ${5:# The authority key identifier as a hex string, where two bytes are separated by colons}
    backup: ${6:# Create a backup file including a timestamp so you can get the original CSR back if you overwrote it with a new one by accident}
    basic_constraints: ${7:# Indicates basic constraints, such as if the certificate is a CA}
    basic_constraints_critical: ${8:# Should the basicConstraints extension be considered as critical}
    common_name: ${9:# The commonName field of the certificate signing request subject}
    country_name: ${10:# The countryName field of the certificate signing request subject}
    create_subject_key_identifier: ${11:# Create the Subject Key Identifier from the public key}
    crl_distribution_points: ${12:# Allows to specify one or multiple CRL distribution points}
    digest: ${13:# The digest used when signing the certificate signing request with the private key}
    email_address: ${14:# The emailAddress field of the certificate signing request subject}
    extended_key_usage: ${15:# Additional restrictions (for example client authentication, server authentication) on the allowed purposes for which the public key may be used}
    extended_key_usage_critical: ${16:# Should the extkeyUsage extension be considered as critical}
    force: ${17:# Should the certificate signing request be forced regenerated by this ansible module}
    group: ${18:# Name of the group that should own the filesystem object, as would be fed to I(chown)}
    key_usage: ${19:# This defines the purpose (for example encipherment, signature, certificate signing) of the key contained in the certificate}
    key_usage_critical: ${20:# Should the keyUsage extension be considered as critical}
    locality_name: ${21:# The localityName field of the certificate signing request subject}
    mode: ${22:# The permissions the resulting filesystem object should have}
    name_constraints_critical: ${23:# Should the Name Constraints extension be considered as critical}
    name_constraints_excluded: ${24:# For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is B(not) allowed to issue certificates for}
    name_constraints_permitted: ${25:# For CA certificates, this specifies a list of identifiers which describe subtrees of names that this CA is allowed to issue certificates for}
    ocsp_must_staple: ${26:# Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools}
    ocsp_must_staple_critical: ${27:# Should the OCSP Must Staple extension be considered as critical}
    organization_name: ${28:# The organizationName field of the certificate signing request subject}
    organizational_unit_name: ${29:# The organizationalUnitName field of the certificate signing request subject}
    owner: ${30:# Name of the user that should own the filesystem object, as would be fed to I(chown)}
    path: ${31:# The name of the file into which the generated OpenSSL certificate signing request will be written}
    privatekey_content: ${32:# The content of the private key to use when signing the certificate signing request}
    privatekey_passphrase: ${33:# The passphrase for the private key}
    privatekey_path: ${34:# The path to the private key to use when signing the certificate signing request}
    return_content: ${35:# If set to V(true), will return the (current or generated) CSR's content as RV(csr)}
    select_crypto_backend: ${36:# Determines which crypto backend to use}
    selevel: ${37:# The level part of the SELinux filesystem object context}
    serole: ${38:# The role part of the SELinux filesystem object context}
    setype: ${39:# The type part of the SELinux filesystem object context}
    seuser: ${40:# The user part of the SELinux filesystem object context}
    state: ${41:# Whether the certificate signing request should exist or not, taking action if the state is different from what is stated}
    state_or_province_name: ${42:# The stateOrProvinceName field of the certificate signing request subject}
    subject: ${43:# Key/value pairs that will be present in the subject name field of the certificate signing request}
    subject_alt_name: ${44:# Subject Alternative Name (SAN) extension to attach to the certificate signing request}
    subject_alt_name_critical: ${45:# Should the subjectAltName extension be considered as critical}
    subject_key_identifier: ${46:# The subject key identifier as a hex string, where two bytes are separated by colons}
    subject_ordered: ${47:# A list of dictionaries, where every dictionary must contain one key/value pair}
    unsafe_writes: ${48:# Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target filesystem object}
    use_common_name_for_san: ${49:# If set to V(true), the module will fill the common name in for O(subject_alt_name) with C(DNS:) prefix if no SAN is specified}
    version: ${50:# The version of the certificate signing request}
  tags:
    - community
    - crypto
    - openssl_csr]]></content>
  <tabTrigger>community.crypto.openssl_csr</tabTrigger>
  <scope>source.yaml,source.ansible</scope>
  <description>Generate OpenSSL Certificate Signing Request (CSR)</description>
</snippet>